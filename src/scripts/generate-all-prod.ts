/**
 * Master Generation Script
 *
 * This script runs all generation scripts for each FormConfiguration file:
 * - Generate Docker Compose
 * - Generate Database Schema
 * - Generate Server Actions
 * - Generate Types
 *
 * Scans the root /configurations folder for form configuration files.
 *
 * Usage: npm run generate:all
 */

import * as path from 'path';
import * as fs from 'fs/promises';
import { createDockerComposeFiles } from './generate-docker-compose';
import { createDatabaseInitFiles } from './db-init';
import { generateServerActions } from './generate-server-actions-ssr';
import { createFormSchemas } from './generate-schema';
import { generateTypes } from './generate-types';
import { discoverFormConfigurations } from './get-project-info';
import type { IFormConfiguration } from '../types/globalFormTypes';
import { generateExportComponent } from './generate-export-components';
import { generateDemoPage } from './generate-demo-pages';
import { generateProdPage } from './generate-prod-pages';

async function generateCombinedTypes(
  configurations: Array<{
    config: IFormConfiguration;
    fileName: string;
    exportName: string;
  }>,
): Promise<string> {
  const exportStatements: string[] = [];

  for (const { config } of configurations) {
    const tableName = config.postgresTableName;
    const capitalizedTableName =
      tableName.charAt(0).toUpperCase() + tableName.slice(1);

    exportStatements.push(
      `export type { ${capitalizedTableName}, ${capitalizedTableName}FormData, Update${capitalizedTableName}Data } from './${tableName}Types';`,
    );
  }

  const header = `/**
 * Generated Type Definitions Index
 * 
 * This file is automatically generated from all FormConfiguration files.
 * Do not edit manually - regenerate using: npm run generate:all
 * 
 * Generated from ${configurations.length} configuration(s):
${configurations.map(({ fileName, exportName }) => ` * - ${fileName} (${exportName})`).join('\n')}
 */


export interface IServerActionResult<T = unknown> {
  success: boolean;
  data?: T;
  error?: string;
}

export interface IPaginatedResult<T = unknown> extends ServerActionResult<T[]> {
  total?: number;
}


${exportStatements.join('\n')}
`;

  return header;
}

async function main() {
  try {
    const projectRoot = path.resolve(__dirname, '../', '../');

    const configurations = await discoverFormConfigurations(projectRoot, true);

    if (configurations.length === 0) {
      process.exit(1);
    }

    const actionsDir = path.join(projectRoot, 'src', 'actions');
    const typesDir = path.join(projectRoot, 'src', 'types');

    await fs.mkdir(actionsDir, { recursive: true });
    await fs.mkdir(typesDir, { recursive: true });

    const generatedFiles: string[] = [];

    for (const { config, fileName, exportName } of configurations) {
      await createDockerComposeFiles(projectRoot);
      generatedFiles.push(`.docker/docker-compose.yml`);
      generatedFiles.push(`postgres_password.txt`);

      await createDatabaseInitFiles(config, projectRoot);
      generatedFiles.push(
        `init-scripts/${config.postgresTableName}-init-tables.sql`,
      );

      await createFormSchemas(config);

      await generateServerActions(config, projectRoot, {
        fileName,
        exportName,
      });
      generatedFiles.push(`src/actions/${config.postgresTableName}.ts`);

      const typeDefinitions = await generateTypes(config);
      const typesFilePath = path.join(
        typesDir,
        `${config.postgresTableName}Types.d.ts`,
      );
      await fs.writeFile(typesFilePath, typeDefinitions, 'utf8');
      generatedFiles.push(`src/types/${config.postgresTableName}Types.d.ts`);

      await generateProdPage(config, projectRoot, { fileName, exportName });
      generatedFiles.push(`src/app/${config.postgresTableName}/page.tsx`);
    }

    const combinedTypes = await generateCombinedTypes(configurations);
    const indexTypesPath = path.join(typesDir, 'generatedTypes.d.ts');
    await fs.writeFile(indexTypesPath, combinedTypes, 'utf8');
    generatedFiles.push('src/types/generatedTypes.d.ts');
  } catch (error) {
    console.error('‚ùå Error generating files:', error);
    process.exit(1);
  }
}

main().catch(console.error);
